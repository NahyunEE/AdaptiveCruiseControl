/**********************************************************************************************************************
 * \file Encoder.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Encoder.h"
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "Driver_Port.h"
#include "Driver_stm.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
typedef struct{
       uint32 SensorA; // 엔코더의 A 센서 값
       uint32 SensorB; // 엔코더의 B 센서 값
}Encoder; // 엔코더 구조체 정의

// 엔코더의 상태를 표현하는 배열
Encoder CountArray[4] = {
    {1, 0}, // 01
    {1, 1}, // 11
    {0, 1}, // 10
    {0, 0}  // 00
};

// 오른쪽 바퀴 엔코더의 현재 상태 및 이전 상태를 저장
Encoder new_EncoderR;
Encoder old_EncoderR;

//Right Motor
double R_w=0; //우측 모터 현재 속도
double R_theta=0; // 우측 모터의 현재 각도
double R_theta_old=0; // 우측 모터의 이전 각도

//Left Motor
double L_theta =0; //좌측 모터의 현재 각도
double L_theta_old=0; //좌측 모터의 이전 각도
double L_w =0; //좌측 모터 현재 속도

double Ts=10;

// 왼쪽 바퀴 엔코더의 현재 상태 및 이전 상태를 저장
Encoder new_EncoderL;
Encoder old_EncoderL;

// 모터 회전 방향 (f: 전진, b: 후진)
uint8 direction = 0;

// 좌,우측 엔코더의 펄스 수
double countR = 0;
double countL = 0;

// 엔코더 카운트를 0으로 초기화하는 함수
void SetCountZero(void) {
    countR = 0;
    countL = 0;
}

double getEncoderR(void){
    // 오른쪽 엔코더 값을 읽어옴
    new_EncoderR.SensorA = IfxPort_getPinState(IfxPort_P14_1.port, IfxPort_P14_1.pinIndex); // Pin23
    new_EncoderR.SensorB = IfxPort_getPinState(IfxPort_P14_0.port, IfxPort_P14_0.pinIndex); // Pin22

    // 이전 상태와 현재 상태에 따라 엔코더 값을 증가 또는 감소시킴
    if(( old_EncoderR.SensorA == 1) && ( old_EncoderR.SensorB==0)){
        if((new_EncoderR.SensorA==1) && (new_EncoderR.SensorB==1)){
            countR--;
            direction='f';
        }else if((new_EncoderR.SensorA==0) && (new_EncoderR.SensorB==0)){
            countR++;
            direction='b';
        }
    }else if((old_EncoderR.SensorA==1) &&( old_EncoderR.SensorB==1)){
        if((new_EncoderR.SensorA==0)&&(new_EncoderR.SensorB==1)){
            countR--;
            direction='f';
        }else if((new_EncoderR.SensorA==1) && (new_EncoderR.SensorB==0)){
            countR++;
            direction='b';
        }
    }else if((old_EncoderR.SensorA==0) && ( old_EncoderR.SensorB==0)){
        if((new_EncoderR.SensorA==1) && (new_EncoderR.SensorB==0)){
            countR--;
            direction='f';
        }else if((new_EncoderR.SensorA==0) && (new_EncoderR.SensorB==1)){
            countR++;
            direction='b';
        }
    }else if((old_EncoderR.SensorA==0) && ( old_EncoderR.SensorB==1)){
        if((new_EncoderR.SensorA==0) && (new_EncoderR.SensorB==0)){
            countR--;
            direction='f';
        }else if((new_EncoderR.SensorA==1) && (new_EncoderR.SensorB==1)){
            countR++;
            direction='b';
        }
    }

    // 이전 상태 갱신
    old_EncoderR.SensorA = new_EncoderR.SensorA;
    old_EncoderR.SensorB = new_EncoderR.SensorB;

    return countR; // 엔코더 값 반환
}

double getEncoderL(void){
    //왼쪽 엔코더 값을 읽어옴
    new_EncoderL.SensorA = IfxPort_getPinState(IfxPort_P00_0.port, IfxPort_P00_0.pinIndex);
    new_EncoderL.SensorB = IfxPort_getPinState(IfxPort_P15_6.port, IfxPort_P15_6.pinIndex);

    // 이전 상태와 현재 상태에 따라 엔코더 값을 증가 또는 감소시킴
    if(( old_EncoderL.SensorA == 1) && ( old_EncoderL.SensorB==0)){
        if((new_EncoderL.SensorA==1) && (new_EncoderL.SensorB==1)){
            countL--;
            direction='f';
        }else if((new_EncoderL.SensorA==0) && (new_EncoderL.SensorB==0)){
            countL++;
            direction='b';
        }
    }
    else if((old_EncoderL.SensorA==1) &&( old_EncoderL.SensorB==1)){
        if((new_EncoderL.SensorA==0)&&(new_EncoderL.SensorB==1)){
            countL--;
            direction='f';
        }else if((new_EncoderL.SensorA==1) && (new_EncoderL.SensorB==0)){
            countL++;
            direction='b';
        }
    }
    else if((old_EncoderL.SensorA==0) && ( old_EncoderL.SensorB==0)){
        if((new_EncoderL.SensorA==1) && (new_EncoderL.SensorB==0)){
            countL--;
            direction='f';
        }else if((new_EncoderL.SensorA==0) && (new_EncoderL.SensorB==1)){
            countL++;
            direction='b';
        }
    }else if((old_EncoderL.SensorA==0) && ( old_EncoderL.SensorB==1)){
        if((new_EncoderL.SensorA==0) && (new_EncoderL.SensorB==0)){
            countL--;
            direction='f';
        }else if((new_EncoderL.SensorA==1) && (new_EncoderL.SensorB==1)){
            countL++;
            direction='b';
        }
    }

    // 이전 상태 갱신
    old_EncoderL.SensorA = new_EncoderL.SensorA;
    old_EncoderL.SensorB = new_EncoderL.SensorB;

    return countL; // 엔코더 값 반환
}
void Encoder_update(){
    // 왼쪽,오른쪽 엔코더 값 업데이트
    getEncoderL();
    getEncoderR();
}
void getRightSpeed(){
    R_theta = 2 * 3.1416 * countR/48; // 오른쪽 바퀴의 회전각을 계산
    R_w= (R_theta-R_theta_old)/Ts; // 오른쪽 바퀴의 각속도를 계산
    R_theta_old = R_theta; // 이전 회전각 저장
}

void getLeftSpeed(){
     L_theta = 2 * 3.1416 * countL/48; // 왼쪽 바퀴의 회전각을 계산
     L_w= (L_theta-L_theta_old)/Ts; // 왼쪽 바퀴의 각속도를 계산
     L_theta_old = L_theta; // 이전 회전각 저장
}
